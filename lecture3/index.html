<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">

    
    <title>Juliaを試してみる - 実験数学1</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../css/base.min.css" rel="stylesheet">
    <link href="../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/github.min.css">
        
    

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="..">実験数学1</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../programming/">なぜプログラミング</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">環境構築 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../c-start/">C言語</a>
</li>

                        
                            
<li >
    <a href="../julia-start/">julia</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">授業 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../lecture1/">C言語を試してみる (出力, if文)</a>
</li>

                        
                            
<li >
    <a href="../lecture2/">for文, while文, 関数</a>
</li>

                        
                            
<li class="active">
    <a href="./">Juliaを試してみる</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../lecture2/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li class="disabled">
                        <a rel="next" >
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#julia">Juliaを使ってみよう</a></li>
            <li class="second-level"><a href="#_1">文字列などの出力</a></li>
                
            <li class="second-level"><a href="#if">if文</a></li>
                
            <li class="second-level"><a href="#forwhile">for文とwhile文</a></li>
                
            <li class="second-level"><a href="#_2">関数</a></li>
                
            <li class="second-level"><a href="#_3">数学関数</a></li>
                
            <li class="second-level"><a href="#_4">再帰関数</a></li>
                
            <li class="second-level"><a href="#_5">配列</a></li>
                
            <li class="second-level"><a href="#-">行列-ベクトル積</a></li>
                
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="julia">Juliaを使ってみよう</h1>
<h2 id="_1">文字列などの出力</h2>
<p>文字列などを出力したいときには，<code>print</code>, <code>println</code>, <code>@printf</code> などを使います．</p>
<pre><code class="language-julia">julia&gt; print(&quot;ab&quot;) # 改行無し出力
ab
julia&gt; print(&quot;ab\n&quot;) # \n は改行
ab

julia&gt; println(&quot;ab&quot;) # 改行付き出力
ab

julia&gt; a = [1,2,3]; # 配列 ← おそらく次回の講義で説明（ベクトルみたいなもの）．また，セミコロンは無くてもよい．

julia&gt; println(a) # 配列も出力できる
[1, 2, 3]

julia&gt; x = 5;

julia&gt; println(x)
5

julia&gt; println(&quot;x&quot;)
x

julia&gt; println(&quot;x = $x&quot;) # 文字列内で計算
x = 5

julia&gt; println(&quot;x + 3 = $(x + 3)&quot;) # 文字列内で計算
x + 3 = 8

julia&gt; println(&quot;a = $a&quot;) # 配列も同様に．
a = [1, 2, 3]

# C のprintfのようなマクロ
julia&gt; using Printf # パッケージ読み込み（Cのincludeに相当）

julia&gt; @printf(&quot;pi = %.8f\n&quot;, pi)
pi = 3.14159265

</code></pre>
<p>関数の使い方を詳しく知りたい時，<a href="https://docs.julialang.org/en/v1/">公式のドキュメント</a> で調べたり，<code>Julia println</code> のようなキーワードでweb検索するのも良いですが，より手軽な次のような方法があります．</p>
<pre><code class="language-julia">julia&gt; 
</code></pre>
<p>この状態で <code>?</code> を押すと</p>
<pre><code class="language-julia">help?&gt; 
</code></pre>
<p>となります．</p>
<p>ここで，例えば，<code>@printf</code> と書いてエンターキーを押すと</p>
<pre><code class="language-julia">help?&gt; @printf
  @printf([io::IOStream], &quot;%Fmt&quot;, args...)

  Print args using C printf style format specification string, with some
  ...
</code></pre>
<p>のように，その関数の使い方が表示されます．ただし，<code>println</code> のようにパッケージ無しで使える関数はいつでも調べることができますが，<code>@printf</code> のように，Printf というパッケージが必要なものの場合，<code>using Printf</code> をせずに（すなわち，パッケージを読み込まずに）<code>?</code> をすると，</p>
<pre><code class="language-julia">help?&gt; @printf
  No documentation found.

  Binding @printf does not exist.
</code></pre>
<p>のようになるので注意しましょう．</p>
<h2 id="if">if文</h2>
<p>公式ドキュメントの例でみてみましょう．考え方はC言語のときと同じですが，文法だけがやや異なります．</p>
<pre><code class="language-julia">(x,y) = (2,3)
if x &lt; y
  println(&quot;x is less than y&quot;)
elseif x &gt; y
  println(&quot;x is greater than y&quot;)
else
  println(&quot;x is equal to y&quot;)
end
</code></pre>
<p>これを実行すれば，</p>
<pre><code class="language-julia">x is less than y
</code></pre>
<p>となります．x と y の値を変えて（大小関係や整数以外）試してみましょう．</p>
<h2 id="forwhile">for文とwhile文</h2>
<p>まず，for文 の例をみてみましょう．</p>
<pre><code class="language-julia">for i = 1:4
  print(&quot;i = $i, &quot;)
end
</code></pre>
<p>とすると出力は</p>
<pre><code class="language-julia">i = 1, i = 2, i = 3, i = 4,
</code></pre>
<p>となります．</p>
<p>また，</p>
<pre><code class="language-julia">for i in [1,4,0]
  print(&quot;i = $i, &quot;)
end
</code></pre>
<p>このような書き方をすれば出力は</p>
<pre><code class="language-julia">i = 1, i = 4, i = 0, 
</code></pre>
<p>となります．</p>
<p>次に while文 の例をみてみましょう．</p>
<pre><code class="language-Julia">i = 1;
while i &lt; 5
  println(i)
  i += 1
end
</code></pre>
<p>これを実行すると出力は</p>
<pre><code class="language-julia">1
2
3
4

</code></pre>
<p>となります．</p>
<h2 id="_2">関数</h2>
<p>例えば，1 から n までの総和を計算する関数 <code>sum</code> は</p>
<pre><code class="language-julia">function sum(n)
  x = 0
  for i = 1:n
    x += i
  end
  return x
end
</code></pre>
<p>のように書きます．使うときは <code>sum(10)</code> のようにすればよいです．</p>
<p>C言語のときとは異なり，引数や戻り値の <strong>型を指定していない</strong> ことに注意してください．実は，<strong>型を指定することもできる</strong> のですが（その方が好ましいこともあります），このように，型を意識せずにプログラムを書けることが，Juliaの手軽さの一つといえます．型の指定の仕方については，Juliaに慣れてきた頃に説明します．</p>
<div class="bs-callout bs-callout-default">
  <h4><i class="fas fa-exclamation-triangle"></i>注意</h4>
  C言語 等に慣れている人にとっては，型を指定しないことはとても気持ち悪く感じるかもしれませんが，これも言語の一つの特性だと思うとよいでしょう．なお，私が研究で Julia を使うときは，まずは，型をあまり意識せずにプログラム書き，だいたいできた段階で，計算時間やメモリ使用量といったパフォーマンスをチェックしながら，必要な箇所で型を指定したりしています．
</div>

<h2 id="_3">数学関数</h2>
<p>標準的な数学関数を利用するために，何らかのパッケージを読み込む必要はありません．</p>
<pre><code class="language-julia"># 例
julia&gt; exp(1)
2.718281828459045

julia&gt; sin(pi/2)
1.0

</code></pre>
<p>ただし，線形代数の演算（例えば内積）などは，例えば <strong>LinearAlgebra</strong> といったパッケージを必要とします．これについては，必要になった時点で解説します．</p>
<h2 id="_4">再帰関数</h2>
<p>Jilia でも再帰関数を定義できます．階乗の計算を行う fact 関数を再帰的に定義する場合，</p>
<pre><code class="language-Julia">function fact(n)
  if n == 0
    return 1
  else
    return n * fact(n-1)
  end
end
</code></pre>
<p>のように書きます．なお，julia にはデフォルトで <code>factorial</code> という関数が準備されています．この関数の定義の仕方が知りたいときは，<a href="https://docs.julialang.org/en/v1/base/math/#Base.factorial">公式のドキュメント</a> の factorial の欄の右下にある source をクリックすることで確認できます．どうやら</p>
<pre><code class="language-julia">function factorial(n::Integer)
    n &lt; 0 &amp;&amp; throw(DomainError(n, &quot;`n` must be nonnegative.&quot;))
    f::typeof(n*n) = 1
    for i::typeof(n*n) = 2:n
        f *= i
    end
    return f
end
</code></pre>
<p>のように定義されているようです．for文 を使って定義されていますね．このように，組み込み関数（デフォルトで準備されている関数）の定義をみると勉強になることも多いです（プロが書いたものなので当然です）．この factorial の例でも，例えば引数の型を整数型としたいときは <code>n::Integer</code> とすればよいことが分かります．</p>
<p>実は，上記の fact 関数 の定義は一行で</p>
<pre><code class="language-julia">fact1(n) = n == 0 ? 1 : n * fact1(n - 1)
</code></pre>
<p>と書くことができます．<code>fact1(n) = ...</code> の <code>...</code> の部分が関数の定義になっていることはイメージしやすいと思います．一方で，初見だと <code>...</code> の部分が意味不明ではないでしょうか？　実は，<code>a ? b : c</code> というのは，</p>
<pre><code class="language-julia">if a 
    b
else
    c
end
</code></pre>
<p>という意味です．実際に調べてみると，以下のように説明されています．</p>
<pre><code class="language-Julia">help?&gt; ?
search: ? ?:

  a ? b : c

  Short form for conditionals; read &quot;if a, evaluate b otherwise evaluate c&quot;.
</code></pre>
<h2 id="_5">配列</h2>
<p>ベクトルや行列（さらにはテンソル）を扱うときには<strong>配列</strong>を利用します．縦ベクトルが一次元配列，行列が二次元配列に対応します．今の段階であまり気にする必要はありませんが，配列の要素は全て同じ型になります．</p>
<p>例を見てみましょう．</p>
<pre><code class="language-Julia">julia&gt; x = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3
</code></pre>
<p>このように，[ ] で囲んで，カンマで区切れば，一次元配列（= 縦ベクトル）になります．</p>
<pre><code class="language-julia">julia&gt; x = [1;2;3]
3-element Array{Int64,1}:
 1
 2
 3
</code></pre>
<p>このようにセミコロンで区切っても同じ結果になります．</p>
<p>二次元配列（= 行列）は次のようにすればよいです．</p>
<pre><code class="language-julia">julia&gt; A = [1 2 3;
            4 5 6;
            7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9
</code></pre>
<p>ここで，配列の要素は整数型です．なお，一つでも実数型にすると，例えば次のようになります．</p>
<pre><code class="language-julia">julia&gt; A = [1.0 2 3;
            4 5 6;
            7 8 9]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0
</code></pre>
<p>行列のベクトルの掛け算には次のように <code>*</code> を使います．</p>
<pre><code class="language-julia">julia&gt; A * x
3-element Array{Int64,1}:
 14
 32
 50
</code></pre>
<p>以下，幾つか重要な例を見てみましょう．</p>
<pre><code class="language-julia"># 全ての値が0の配列
julia&gt; zeros(2) # デフォルトはFloat64型
2-element Array{Float64,1}:
 0.0
 0.0

julia&gt; zeros(Int64,2) # 型を指定したければこのように．
2-element Array{Int64,1}:
 0
 0

julia&gt; zeros(Int64,2, 3) # 零行列
2×3 Array{Int64,2}:
 0  0  0
 0  0  0

# 全ての値が1の配列
julia&gt; ones(2)
2-element Array{Float64,1}:
 1.0
 1.0

julia&gt; ones(Int64,2)
2-element Array{Int64,1}:
 1
 1

julia&gt; ones(Int64,2,3)
2×3 Array{Int64,2}:
 1  1  1
 1  1  1

# 一様分布でランダムに初期化した配列
julia&gt; rand(2,3)
2×3 Array{Float64,2}:
 0.146656  0.330993  0.462748
 0.404141  0.318241  0.367632

# 正規分布でランダムに初期化した配列
julia&gt; randn(2,3)
2×3 Array{Float64,2}:
 2.35716   1.44751   0.813044
 1.49665  -0.677559  0.467396
</code></pre>
<p>配列の要素は，<code>A[i,j]</code> のように取り出します．代入も同様です．</p>
<pre><code class="language-julia">julia&gt; A = rand(2,3)
2×3 Array{Float64,2}:
 0.718872  0.349552   0.10818
 0.13624   0.0399332  0.241702

# 要素の取り出し
julia&gt; A[1,2]
0.34955168533252645

# 要素の代入
julia&gt; A[1,2] = 1.0;

julia&gt; A
2×3 Array{Float64,2}:
 0.718872  1.0        0.10818
 0.13624   0.0399332  0.241702
</code></pre>
<p>Juliaでは，配列のインデックスは 1 からはじまります．C言語など，他の幾つかの言語では，配列のインデックスは 0 からはじまるので，そのような言語に慣れている方にとっては，少し違和感を覚えるかもしれませんが，「Juliaではそういうルールなのだ」と思えば良いでしょう．</p>
<h2 id="-">行列-ベクトル積</h2>
<p>行列とベクトルの掛け算は，<code>A * x</code> のように簡単に書けるわけですが，もう少し注意深く考えてみましょう．<script type="math/tex">A\in\mathbb{R}^{m\times n}</script> と ベクトル <script type="math/tex">x\in\mathbb{R}^{n}</script> に対して，それらの積 <script type="math/tex">Ax</script> は，</p>
<p>
<script type="math/tex; mode=display">(Ax)_i = \sum_{j=1}^n a_{ij} x_j</script>
</p>
<p>ですから，<script type="math/tex">y = Ax</script>を計算したければ，</p>
<pre><code class="language-julia">julia&gt; A = randn(3,2)
3×2 Array{Float64,2}:
 -0.0770241  -0.0941118
  2.37894     0.198019
  0.681646    1.17241

julia&gt; x = randn(2)
2-element Array{Float64,1}:
 -0.3890395113596626
 -1.0779098168822268

julia&gt; y = zeros(3);

julia&gt; for i = 1:3
           for j = 1:2
               y[i] = y[i] + A[i,j] * x[j]
           end
       end
</code></pre>
<p>とすればよさそうです．このとき，結果は</p>
<pre><code class="language-Julia">julia&gt; y
3-element Array{Float64,1}:
  0.1314095002691501
 -1.1389493877360208
 -1.5289372130207397
</code></pre>
<p>となり，<code>A * x</code> の結果</p>
<pre><code class="language-julia">julia&gt; A * x
3-element Array{Float64,1}:
  0.1314095002691501
 -1.1389493877360208
 -1.5289372130207397
</code></pre>
<p>と確かに一致します．もっとも，二重になっている for文 の順番を入れ替えて</p>
<pre><code class="language-julia">julia&gt; z = zeros(3)
3-element Array{Float64,1}:
 0.0
 0.0
 0.0

julia&gt; for j = 1:2
           for i = 1:3
               z[i] = z[i] + A[i,j] * x[j]
           end
       end
</code></pre>
<p>としても，やはり結果は</p>
<pre><code class="language-julia">julia&gt; z
3-element Array{Float64,1}:
  0.1314095002691501
 -1.1389493877360208
 -1.5289372130207397
</code></pre>
<p>となります．「数学的には同じなのだから当たり前ではないか！」と思われるかもしれませんが，実はちょっとした違いがあります．</p>
<p>簡単のために <script type="math/tex">A</script> は正方行列として，そのサイズを <script type="math/tex">n=10000</script> としましょう．行列 <script type="math/tex">A</script> とベクトル <script type="math/tex">x</script> を次のように初期化しておきます．</p>
<pre><code class="language-julia">julia&gt; n = 10000;

julia&gt; A = randn(n,n);

julia&gt; x = ones(n);
</code></pre>
<p>そして，行列ベクトル積を計算する関数を2つ準備しましょう．</p>
<pre><code class="language-julia">julia&gt; function matvec1(A,x)
           n = length(x)
           y = zeros(n)
           for i = 1:n
               for j = 1:n
                   y[i] += A[i,j] * x[j]
               end
           end
           return y
       end     
matvec1 (generic function with 1 method)

julia&gt; function matvec2(A,x)
           n = length(x)
           y = zeros(n)
           for j = 1:n
               for i = 1:n
                   y[i] += A[i,j] * x[j]
               end
           end
           return y
       end
matvec2 (generic function with 1 method)
</code></pre>
<p>違いは，for文 の順番だけです．これらの関数を使って，行列ベクトル積を計算するときの実行時間を測ってみましょう．そのためには，<code>@time</code> というコマンドを使います．以下の結果は，実行する環境によって異なりますが，私のラップトップでは次のようになりました．（実行する度に計算時間は異なるはずですが，「1回目」は極端に遅い可能性があるので，2回目以降（何回やってもだいたい同じ）で比較してみるとよいでしょう）</p>
<pre><code class="language-julia">julia&gt; @time matvec1(A,x);
  0.773708 seconds (2 allocations: 78.203 KiB)

julia&gt; @time matvec2(A,x);
  0.105140 seconds (2 allocations: 78.203 KiB)
</code></pre>
<p>外側に j のループがある <code>matvec2</code> の方が圧倒的に速いですね．なお，<code>*</code> を使えば</p>
<pre><code class="language-julia">julia&gt; @time A * x;
  0.019867 seconds (2 allocations: 78.203 KiB)
</code></pre>
<p>のようにより高速です．どのように計算されているか関心がある人はドキュメントを読んでみるとよいでしょう．</p></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>© 2021 Yuto Miyatake</small><br>
            
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = ".."</script>
    
    <script src="../js/base.js"></script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
